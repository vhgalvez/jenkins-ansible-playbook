# playbooks/01_generate-admin-secret.yml
# ----------------------------------------------------------------------------- 
# Genera y sella (kubeseal) el Secret «jenkins‑admin»
#   • Usuario/contraseña de la UI  (stringData) 
#   • Contraseña bcrypt con prefijo #jbcrypt:  (requisito Jenkins)
# -----------------------------------------------------------------------------

- name: 🔐 Generar y sellar el Secret «jenkins-admin»
  hosts: localhost
  gather_facts: false

  vars_files:
    - ../vars/main.yml            # rutas, kubeseal_path, kubeconfig, etc.

  vars:
    # Rutas de trabajo
    files_dir: "{{ playbook_dir }}/files"
    admin_secret_template: "../templates/secret/jenkins-admin-secret.yaml.j2"
    rendered_admin_secret_path: "{{ files_dir }}/jenkins-admin-unsealed.yaml"
    sealed_admin_secret_path:   "{{ files_dir }}/jenkins-admin-sealed.yaml"

    # Claves dentro del Secret
    jenkins_admin_secret_name: jenkins-admin
    jenkins_admin_user_key:  jenkins-admin-user
    jenkins_admin_pass_key:  jenkins-admin-password

  tasks:
  # ---------------------------------------------------------------------------
  # 1. Cargar .env y extraer credenciales de la UI
  # ---------------------------------------------------------------------------
  - name: 📥 Cargar .env (si existe) y volcar variables a la shell
    ansible.builtin.shell: |
      if [ -f "{{ playbook_dir }}/../.env" ]; then
        set -a && . "{{ playbook_dir }}/../.env" && set +a
      fi
      env
    args:
      executable: /bin/bash
    register: env_output
    changed_when: false

  - name: 📌 Registrar variables JENKINS_AUTH_*_UI (robusto)
    ansible.builtin.set_fact:
      jenkins_auth_user_ui: >-
        {{ (env_output.stdout_lines
           | select('match', '^JENKINS_AUTH_USER_UI=')
           | map('regex_replace', '^JENKINS_AUTH_USER_UI=', '')
           | list | first | default('', true)) }}
      jenkins_auth_pass_ui_raw: >-
        {{ (env_output.stdout_lines
           | select('match', '^JENKINS_AUTH_PASS_UI=')
           | map('regex_replace', '^JENKINS_AUTH_PASS_UI=', '')
           | list | first | default('', true)) }}

  - name: ❌ Validar que user y pass UI existan
    ansible.builtin.assert:
      that:
        - jenkins_auth_user_ui | length > 0
        - jenkins_auth_pass_ui_raw | length > 0
      fail_msg: |
        Faltan variables JENKINS_AUTH_USER_UI o JENKINS_AUTH_PASS_UI
        en el archivo .env o en el entorno de ejecución.

  # ---------------------------------------------------------------------------
  # 2. Asegurar dependencia «bcrypt» en el controlador Ansible
  # ---------------------------------------------------------------------------
  - name: 🔍 Verificar módulo bcrypt disponible
    ansible.builtin.shell: |
      python3 - <<'PY'
      import bcrypt, sys
      PY
    args:
      executable: /bin/bash
    register: bcrypt_check
    failed_when: false
    changed_when: false

  - name: ➕ Instalar bcrypt si falta
    ansible.builtin.shell: |
      python3 -m pip install --quiet bcrypt
    args:
      executable: /bin/bash
    when: bcrypt_check.rc != 0
    register: pip_install
    changed_when: "'Successfully installed' in pip_install.stdout or pip_install.stderr"

  # ---------------------------------------------------------------------------
  # 3. Generar hash bcrypt con prefijo #jbcrypt:
  # ---------------------------------------------------------------------------
  - name: 🔑 Hashear contraseña UI con bcrypt
    ansible.builtin.shell: |
      python3 - <<'PY'
      import bcrypt, os, sys
      pwd = os.environ["PLAINTEXT"].encode()
      print('#jbcrypt:' + bcrypt.hashpw(pwd, bcrypt.gensalt(prefix=b'2a')).decode())
      PY
    args:
      executable: /bin/bash
    environment:
      PLAINTEXT: "{{ jenkins_auth_pass_ui_raw }}"
    register: bcrypt_hash_result
    changed_when: false
    no_log: true          # oculta el hash en los logs

  - name: 💾 Guardar hash en variable
    ansible.builtin.set_fact:
      jenkins_auth_pass_ui_bcrypt: "{{ bcrypt_hash_result.stdout }}"

  - name: 🔍 Validar que el hash bcrypt se generó correctamente
    ansible.builtin.assert:
      that:
        - jenkins_auth_pass_ui_bcrypt is defined
        - jenkins_auth_pass_ui_bcrypt | length > 30
        - jenkins_auth_pass_ui_bcrypt.startswith('#jbcrypt:$2a$')
      fail_msg: "❌ Hash bcrypt inválido o vacío. Revisa la generación."

  # ---------------------------------------------------------------------------
  # 4. Renderizar, sellar y aplicar el Secret
  # ---------------------------------------------------------------------------
  - name: 📂 Asegurar directorio temporal
    ansible.builtin.file:
      path: "{{ files_dir }}"
      state: directory
      mode: "0755"
    changed_when: false

  - name: 📝 Renderizar Secret jenkins-admin (sin sellar)
    ansible.builtin.template:
      src: "{{ admin_secret_template }}"
      dest: "{{ rendered_admin_secret_path }}"

  - name: 🔐 Sellar el Secret con kubeseal
    ansible.builtin.shell: |
      {{ kubeseal_path }} \
        --controller-name sealed-secrets-controller \
        --controller-namespace kube-system \
        --format yaml \
        < "{{ rendered_admin_secret_path }}" \
        > "{{ sealed_admin_secret_path }}"
    environment:
      KUBECONFIG: "{{ kubeconfig_path }}"
    changed_when: true

  - name: 🗑️ Eliminar archivo temporal sin sellar
    ansible.builtin.file:
      path: "{{ rendered_admin_secret_path }}"
      state: absent
    changed_when: false

  - name: 🚀 Aplicar SealedSecret jenkins-admin
    ansible.builtin.command: >
      {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }}
      apply -f {{ sealed_admin_secret_path }}
    register: apply_result
    changed_when: "'created' in apply_result.stdout or 'configured' in apply_result.stdout"

  - name: ✅ Resultado
    ansible.builtin.debug:
      msg: "{{ apply_result.stdout | default(apply_result.stderr) }}"
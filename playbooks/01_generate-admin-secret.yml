# ---------------------------------------------------------------------------
# Genera y sella el Secret «jenkins-admin»
#   • Crea el hash bcrypt (#jbcrypt:…) ANTES de sellar
#   • Aplica el SealedSecret al cluster
# ---------------------------------------------------------------------------
- name: 🔐 Generar y sellar el Secret «jenkins-admin»
  hosts: localhost
  gather_facts: false

  vars_files:
    - ../vars/main.yml            # kubeconfig_path, kubeseal_path, etc.

  vars:
    files_dir: "{{ playbook_dir }}/files"
    admin_tpl:  "../templates/secret/jenkins-admin-secret.yaml.j2"
    tmp_plain:  "{{ files_dir }}/jenkins-admin-unsealed.yaml"
    tmp_sealed: "{{ files_dir }}/jenkins-admin-sealed.yaml"

    jenkins_admin_secret_name: jenkins-admin
    jenkins_admin_user_key:    jenkins-admin-user
    jenkins_admin_pass_key:    jenkins-admin-password

  tasks:
    # 1.  Leer .env y tomar credenciales UI
    - name: 📥 Cargar .env (si existe) y exportar variables
      shell: |
        if [ -f "{{ playbook_dir }}/../.env" ]; then
          set -a && . "{{ playbook_dir }}/../.env" && set +a
        fi
        env
      args: { executable: /bin/bash }
      register: env_out
      changed_when: false

    - name: 📌 Extraer JENKINS_AUTH_*_UI
      set_fact:
        jenkins_auth_user_ui: "{{ lookup('env','JENKINS_AUTH_USER_UI') | default('', true) }}"
        jenkins_auth_pass_ui: "{{ lookup('env','JENKINS_AUTH_PASS_UI') | default('', true) }}"

    - name: ❌ Validar usuario y contraseña
      assert:
        that:
          - jenkins_auth_user_ui | length > 0
          - jenkins_auth_pass_ui | length > 0
        fail_msg: "Faltan JENKINS_AUTH_USER_UI o JENKINS_AUTH_PASS_UI en .env"

    # 2.  Garantizar dependencia «bcrypt» y generar hash
    - name: 🔍 Verificar módulo bcrypt
      shell: python3 -c "import bcrypt" || true
      register: bcrypt_check
      changed_when: false

    - name: ➕ Instalar bcrypt si falta
      shell: python3 -m pip install --quiet bcrypt
      when: bcrypt_check.rc != 0

    - name: 🔑 Hashear contraseña UI → #jbcrypt:…
      shell: |
        python3 - <<'PY'
        import bcrypt, os, sys
        pwd = os.environ['PLAINTEXT'].encode()
        print('#jbcrypt:' + bcrypt.hashpw(pwd, bcrypt.gensalt(prefix=b'2a')).decode())
        PY
      args: { executable: /bin/bash }
      environment:
        PLAINTEXT: "{{ jenkins_auth_pass_ui }}"
      register: bcrypt_hash
      changed_when: false
      no_log: true

    - name: 💾 Guardar hash en fact
      set_fact:
        jenkins_auth_pass_ui_hashed: "{{ bcrypt_hash.stdout }}"

    # 3.  Renderizar → Sellar → Aplicar
    - name: 📂 Crear carpeta temporal
      file:
        path: "{{ files_dir }}"
        state: directory
        mode: '0755'
      changed_when: false

    - name: 📝 Renderizar Secret (sin sellar)
      template:
        src: "{{ admin_tpl }}"
        dest: "{{ tmp_plain }}"

    - name: 🔐 Sellar el Secret con kubeseal
      shell: |
        {{ kubeseal_path }} \
          --controller-name sealed-secrets-controller \
          --controller-namespace kube-system \
          --format yaml < "{{ tmp_plain }}" > "{{ tmp_sealed }}"
      environment: { KUBECONFIG: "{{ kubeconfig_path }}" }
      changed_when: true

    - name: 🗑️ Limpiar archivo sin sellar
      file:
        path: "{{ tmp_plain }}"
        state: absent
      changed_when: false

    - name: 🚀 Aplicar SealedSecret al cluster
      command: >
        {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }}
        apply -f {{ tmp_sealed }}
      register: apply_res
      changed_when: "'created' in apply_res.stdout or 'configured' in apply_res.stdout"

    - name: ✅ Resultado final
      debug:
        msg: "{{ apply_res.stdout | default(apply_res.stderr) }}"
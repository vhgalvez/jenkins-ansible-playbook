# playbooks/01_generate-admin-secret.yml
# ---------------------------------------------------------------------------
# Genera y sella el Secret Â«jenkins-adminÂ» con la contraseÃ±a en bcrypt
# ---------------------------------------------------------------------------
- name: ğŸ” Generar y sellar el Secret Â«jenkins-adminÂ»
  hosts: localhost
  gather_facts: false

  vars_files:
    - ../vars/main.yml

  vars:
    work_dir:            "{{ playbook_dir }}/files"
    tpl_secret:          "../templates/secret/jenkins-admin-secret.yaml.j2"
    tmp_plain:           "{{ work_dir }}/jenkins-admin-unsealed.yaml"
    tmp_sealed:          "{{ work_dir }}/jenkins-admin-sealed.yaml"

    jenkins_admin_secret_name: jenkins-admin
    jenkins_admin_user_key:    jenkins-admin-user
    jenkins_admin_pass_key:    jenkins-admin-password

  tasks:
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1. cargar .env â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - name: ğŸ“¥ Leer .env (si existe) en base64                      # no falla si estÃ¡
    slurp:
      src: "{{ playbook_dir }}/../.env"
    register: env_file
    ignore_errors: false           # fallarÃ¡ si .env no existe

  - name: ğŸ“ƒ Parsear .env â†’ lista de lÃ­neas
    set_fact:
      env_lines: "{{ env_file.content | b64decode | split('\n') }}"
      #      â¬‘â¬‘â¬‘ aquÃ­ el cambio: split('\n') en lugar de splitlines()

  - name: ğŸ“Œ Extraer credenciales UI
    set_fact:
      jenkins_auth_user_ui: >-
        {{ env_lines | select('match','^JENKINS_AUTH_USER_UI=') | list | first | regex_replace('^JENKINS_AUTH_USER_UI=', '') | default('') }}
      jenkins_auth_pass_ui: >-
        {{ env_lines | select('match','^JENKINS_AUTH_PASS_UI=') | list | first | regex_replace('^JENKINS_AUTH_PASS_UI=', '') | default('') }}

  - name: âŒ Validar que existen usuario y contraseÃ±a
    assert:
      that:
        - jenkins_auth_user_ui | length > 0
        - jenkins_auth_pass_ui | length > 0
      fail_msg: "âŒ Faltan JENKINS_AUTH_USER_UI o JENKINS_AUTH_PASS_UI en .env"

  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. dependencia bcrypt + hash seguro â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - name: ğŸ” Verificar mÃ³dulo bcrypt
    shell: python3 -c "import bcrypt" || true
    register: bcrypt_check
    changed_when: false

  - name: â• Instalar bcrypt si falta
    shell: python3 -m pip install --quiet bcrypt
    when: bcrypt_check.rc != 0

  - name: ğŸ”‘ Generar hash bcrypt (#jbcrypt:â€¦)
    shell: |
      python3 - <<'PY'
      import bcrypt, os, sys
      pwd = os.environ['PLAINTEXT'].encode()
      print('#jbcrypt:' + bcrypt.hashpw(pwd, bcrypt.gensalt(prefix=b'2a')).decode())
      PY
    args: { executable: /bin/bash }
    environment:
      PLAINTEXT: "{{ jenkins_auth_pass_ui }}"
    register: bcrypt_hash
    changed_when: false
    no_log: true

  - set_fact: { jenkins_auth_pass_ui_hashed: "{{ bcrypt_hash.stdout }}" }

  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3. render â†’ sellar â†’ aplicar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - name: ğŸ“‚ Asegurar carpeta temporal
    file:
      path: "{{ work_dir }}"
      state: directory
      mode: 0755
    changed_when: false

  - name: ğŸ“ Renderizar Secret (sin sellar)
    template:
      src:  "{{ tpl_secret }}"
      dest: "{{ tmp_plain }}"

  - name: ğŸ” Sellar con kubeseal
    shell: |
      {{ kubeseal_path }} \
        --controller-name sealed-secrets-controller \
        --controller-namespace kube-system \
        --format yaml < "{{ tmp_plain }}" > "{{ tmp_sealed }}"
    environment: { KUBECONFIG: "{{ kubeconfig_path }}" }
    changed_when: true

  - name: ğŸ—‘ï¸ Borrar el YAML sin sellar
    file: { path: "{{ tmp_plain }}", state: absent }
    changed_when: false

  - name: ğŸš€ Aplicar SealedSecret
    command: >
      {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }}
      apply -f {{ tmp_sealed }}
    register: apply_res
    changed_when: "'created' in apply_res.stdout or 'configured' in apply_res.stdout"

  - name: âœ… SealedSecret aplicado
    debug: { msg: "{{ apply_res.stdout | default(apply_res.stderr) }}" }
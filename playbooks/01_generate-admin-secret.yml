# playbooks/01_generate-admin-secret.yml
# ---------------------------------------------------------------------------
# Genera y sella el Secret «jenkins-admin» con la contraseña en bcrypt
# ---------------------------------------------------------------------------
- name: 🔐 Generar y sellar el Secret «jenkins-admin»
  hosts: localhost
  gather_facts: false

  vars_files:
    - ../vars/main.yml

  vars:
    work_dir:            "{{ playbook_dir }}/files"
    tpl_secret:          "../templates/secret/jenkins-admin-secret.yaml.j2"
    tmp_plain:           "{{ work_dir }}/jenkins-admin-unsealed.yaml"
    tmp_sealed:          "{{ work_dir }}/jenkins-admin-sealed.yaml"

    jenkins_admin_secret_name: jenkins-admin
    jenkins_admin_user_key:    jenkins-admin-user
    jenkins_admin_pass_key:    jenkins-admin-password

  tasks:
  #───────────────────────────── 1. cargar .env ─────────────────────────────
  - name: 📥 Leer .env (si existe) en base64                      # no falla si está
    slurp:
      src: "{{ playbook_dir }}/../.env"
    register: env_file
    ignore_errors: false           # fallará si .env no existe

  - name: 📃 Parsear .env → lista de líneas
    set_fact:
      env_lines: "{{ env_file.content | b64decode | split('\n') }}"
      #      ⬑⬑⬑ aquí el cambio: split('\n') en lugar de splitlines()

  - name: 📌 Extraer credenciales UI
    set_fact:
      jenkins_auth_user_ui: >-
        {{ env_lines | select('match','^JENKINS_AUTH_USER_UI=') | list | first | regex_replace('^JENKINS_AUTH_USER_UI=', '') | default('') }}
      jenkins_auth_pass_ui: >-
        {{ env_lines | select('match','^JENKINS_AUTH_PASS_UI=') | list | first | regex_replace('^JENKINS_AUTH_PASS_UI=', '') | default('') }}

  - name: ❌ Validar que existen usuario y contraseña
    assert:
      that:
        - jenkins_auth_user_ui | length > 0
        - jenkins_auth_pass_ui | length > 0
      fail_msg: "❌ Faltan JENKINS_AUTH_USER_UI o JENKINS_AUTH_PASS_UI en .env"

  #──────────────────── 2. dependencia bcrypt + hash seguro ────────────────
  - name: 🔍 Verificar módulo bcrypt
    shell: python3 -c "import bcrypt" || true
    register: bcrypt_check
    changed_when: false

  - name: ➕ Instalar bcrypt si falta
    shell: python3 -m pip install --quiet bcrypt
    when: bcrypt_check.rc != 0

  - name: 🔑 Generar hash bcrypt (#jbcrypt:…)
    shell: |
      python3 - <<'PY'
      import bcrypt, os, sys
      pwd = os.environ['PLAINTEXT'].encode()
      print('#jbcrypt:' + bcrypt.hashpw(pwd, bcrypt.gensalt(prefix=b'2a')).decode())
      PY
    args: { executable: /bin/bash }
    environment:
      PLAINTEXT: "{{ jenkins_auth_pass_ui }}"
    register: bcrypt_hash
    changed_when: false
    no_log: true

  - set_fact: { jenkins_auth_pass_ui_hashed: "{{ bcrypt_hash.stdout }}" }

  #──────────────────────── 3. render → sellar → aplicar ────────────────────
  - name: 📂 Asegurar carpeta temporal
    file:
      path: "{{ work_dir }}"
      state: directory
      mode: 0755
    changed_when: false

  - name: 📝 Renderizar Secret (sin sellar)
    template:
      src:  "{{ tpl_secret }}"
      dest: "{{ tmp_plain }}"

  - name: 🔐 Sellar con kubeseal
    shell: |
      {{ kubeseal_path }} \
        --controller-name sealed-secrets-controller \
        --controller-namespace kube-system \
        --format yaml < "{{ tmp_plain }}" > "{{ tmp_sealed }}"
    environment: { KUBECONFIG: "{{ kubeconfig_path }}" }
    changed_when: true

  - name: 🗑️ Borrar el YAML sin sellar
    file: { path: "{{ tmp_plain }}", state: absent }
    changed_when: false

  - name: 🚀 Aplicar SealedSecret
    command: >
      {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }}
      apply -f {{ tmp_sealed }}
    register: apply_res
    changed_when: "'created' in apply_res.stdout or 'configured' in apply_res.stdout"

  - name: ✅ SealedSecret aplicado
    debug: { msg: "{{ apply_res.stdout | default(apply_res.stderr) }}" }
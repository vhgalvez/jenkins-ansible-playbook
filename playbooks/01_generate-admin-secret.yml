# playbooks/01_generate-admin-secret.yml
# -----------------------------------------------------------------------------
# Genera y sella (kubeseal) el Secret jenkins‚Äëadmin
#   ‚Ä¢ Usuario/contrase√±a de la UI                       (stringData)
#   ‚Ä¢ Contrase√±a en formato bcrypt con prefijo #jbcrypt:
# -----------------------------------------------------------------------------

- name: üîê Generar y sellar el Secret ¬´jenkins-admin¬ª
  hosts: localhost
  gather_facts: false

  vars_files:
    - ../vars/main.yml

  vars:
    # Rutas y nombres clave
    files_dir: "{{ playbook_dir }}/files"
    admin_secret_template: "../templates/secret/jenkins-admin-secret.yaml.j2"
    rendered_admin_secret_path: "{{ files_dir }}/jenkins-admin-unsealed.yaml"
    sealed_admin_secret_path: "{{ files_dir }}/jenkins-admin-sealed.yaml"

    # Claves dentro del Secret
    jenkins_admin_secret_name: jenkins-admin
    jenkins_admin_user_key: jenkins-admin-user
    jenkins_admin_pass_key: jenkins-admin-password

  tasks:
    # ---------------------------------------------------------------------------
    # 1. Cargar .env y extraer credenciales de la UI
    # ---------------------------------------------------------------------------
    - name: üì• Cargar .env (si existe) y exportar variables
      ansible.builtin.shell: |
        if [ -f "{{ playbook_dir }}/../.env" ]; then
          set -a && . "{{ playbook_dir }}/../.env" && set +a
        fi
        env
      args:
        executable: /bin/bash
      register: env_output
      changed_when: false

    - name: üìå Registrar variables JENKINS_AUTH_*_UI
      ansible.builtin.set_fact:
        jenkins_auth_user_ui: >-
          {{ env_output.stdout_lines
             | select('match', '^JENKINS_AUTH_USER_UI=')
             | first | regex_replace('^JENKINS_AUTH_USER_UI=', '')
             | default('', true) }}
        jenkins_auth_pass_ui_raw: >-
          {{ env_output.stdout_lines
             | select('match', '^JENKINS_AUTH_PASS_UI=')
             | first | regex_replace('^JENKINS_AUTH_PASS_UI=', '')
             | default('', true) }}

    - name: ‚ùå Validar que user y pass UI existan
      ansible.builtin.assert:
        that:
          - jenkins_auth_user_ui | length > 0
          - jenkins_auth_pass_ui_raw | length > 0
        fail_msg: "Faltan JENKINS_AUTH_USER_UI o JENKINS_AUTH_PASS_UI"

    # ---------------------------------------------------------------------------
    # 2. Asegurar la dependencia ‚Äúbcrypt‚Äù (solo para root)
    # ---------------------------------------------------------------------------
    - name: üîç Verificar que el m√≥dulo bcrypt est√© disponible
      ansible.builtin.shell: |
        python3 - <<'PY'
        import bcrypt, sys
        PY
      args:
        executable: /bin/bash
      register: bcrypt_check
      failed_when: false
      changed_when: false

    - name: ‚ûï Instalar bcrypt para root si falta
      ansible.builtin.shell: "python3 -m pip install --quiet bcrypt"
      args:
        executable: /bin/bash
      when: bcrypt_check.rc != 0
      register: pip_install
      changed_when: "'Successfully installed' in pip_install.stdout or pip_install.stderr"

    # ---------------------------------------------------------------------------
    # 3. Generar hash bcrypt  (#jbcrypt:‚Ä¶)
    # ---------------------------------------------------------------------------
    - name: üîë Hashear contrase√±a UI con bcrypt
      ansible.builtin.shell: |
        python3 - <<'PY'
        import bcrypt, os
        pwd = os.environ["PLAINTEXT"].encode()
        print('#jbcrypt:' + bcrypt.hashpw(pwd, bcrypt.gensalt(prefix=b'2a')).decode())
        PY
      args:
        executable: /bin/bash
      environment:
        PLAINTEXT: "{{ jenkins_auth_pass_ui_raw }}"
      register: bcrypt_hash_result
      changed_when: false
      no_log: true # oculta el hash en los registros

    - name: üíæ Guardar hash en variable
      ansible.builtin.set_fact:
        jenkins_auth_pass_ui_bcrypt: "{{ bcrypt_hash_result.stdout }}"

    # ---------------------------------------------------------------------------
    # 4. Renderizar, sellar y aplicar el Secret
    # ---------------------------------------------------------------------------
    - name: üìÇ Asegurar directorio temporal
      ansible.builtin.file:
        path: "{{ files_dir }}"
        state: directory
        mode: "0755"
      changed_when: false

    - name: üìù Renderizar Secret jenkins-admin (sin sellar)
      ansible.builtin.template:
        src: "{{ admin_secret_template }}"
        dest: "{{ rendered_admin_secret_path }}"
      # ‚ÄºÔ∏è¬†No se declara bloque ‚Äúvars:‚Äù ‚Äë las variables ya est√°n en el contexto

    - name: üîê Sellar el Secret con kubeseal
      ansible.builtin.shell: |
        {{ kubeseal_path }} \
          --controller-name sealed-secrets-controller \
          --controller-namespace kube-system \
          --format yaml \
          < "{{ rendered_admin_secret_path }}" \
          > "{{ sealed_admin_secret_path }}"
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      changed_when: true

    - name: üóëÔ∏è Eliminar archivo temporal sin sellar
      ansible.builtin.file:
        path: "{{ rendered_admin_secret_path }}"
        state: absent
      changed_when: false

    - name: üöÄ Aplicar SealedSecret jenkins-admin
      ansible.builtin.command: >
        {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }}
        apply -f {{ sealed_admin_secret_path }}
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: apply_result
      changed_when: "'created' in apply_result.stdout or 'configured' in apply_result.stdout"

    - name: ‚úÖ Resultado
      ansible.builtin.debug:
        msg: "{{ apply_result.stdout | default(apply_result.stderr) }}"
